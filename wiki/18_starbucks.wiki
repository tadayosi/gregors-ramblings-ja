#summary スターバックスは2フェーズコミットを使わない http://www.eaipatterns.com/ramblings/18_starbucks.html
#labels 翻訳完了

= スターバックスは2フェーズコミットを使わない =
（原文） http://www.eaipatterns.com/ramblings/18_starbucks.html

2004年11月19日

== ホットココア　ヲ　クダサーイ (Hotto Cocoa o Kudasai) ==

2週間の日本旅行から帰ってきた。日本で見られる有名な景色の1つに、ありえない数のスターバックス・コーヒーショップがある。とくに、新宿と六本木がすごいことになっている。注文した「ホットココア」を待っている間に、スターバックスでどのように飲み物の注文が処理されているのかを考えてみた。スターバックスは、他のビジネスだってみんな同じだけれど、注文のスループット（処理量）を最大化することを第一に考えている。注文が多ければ多いほど、儲かるからだ。その結果、スターバックスは非同期処理をやる。お客が注文をすると、レジの店員はコーヒーカップに注文の印を付けて、キューに送る。キューというのは、エスプレッソマシンの上に一列に並んだ、文字通りコーヒーカップのキュー（待ち行列）だ。このキューはレジ係とバリスタ ^訳注1^ とを分割し、バリスタが一時的にモタモタしたとしてもレジ係は注文を受け続けることができる。この方法なら、もしお店が忙しくなっても、[http://www.eaipatterns.com/CompetingConsumers.html Competing Consumer] のシナリオのようにバリスタを複数人配置して捌くことだってできる。

_訳注1: コーヒーを淹れる人_

== 相関関係 (Correlation) ==

非同期なアプローチから利益を得る代償に、スターバックスは同じく非同期性が本質的に持ち込んでしまう課題にも対処しなければならない。その一例が、相関関係（correlation）だ。飲み物の注文は、必ずしもその注文を受けた順番に完了するとは限らない。順序の入れ替わりは、2つの理由により起こりうる。まず、バリスタが複数人いて、別々の装置を使って注文を処理していることもある。ブレンドして作られる飲み物は、ドリップコーヒーより時間が掛かるかもしれない。二番目に、バリスタが処理時間を最適化するために、バッチ処理で飲み物を何個かまとめて作るかもしれない。その結果、スターバックスは相関関係の問題をかかえる。飲み物はばらばらの順序で手渡されるので、正しい客との対応付けが必要になるのだ。スターバックスはこの問題を、私たちがメッセージングアーキテクチャで用いるのと同じ「パターン」によって解決している――彼らは [http://www.eaipatterns.com/CorrelationIdentifier.html Correlation Identifier] を使っている。米国のほとんどのスターバックスでは、カップにお客さんの名前を書いて、飲み物が出来上がったら名前を呼ぶ。そうやって、明示的に相関関係識別子（correlation identifier）を使っている。その他の国では、お客が飲み物の種類から相関を判断しなければならない。

== 例外処理 (Exception Handling) ==

非同期メッセージングのシナリオの中で、例外処理を考えるのは難しい。もし現実世界の中に最善のストーリーが描かれているとするなら、スターバックスがどうやって例外に対応しているかを観察することで、何かを学べるかもしれない。もしお客がお金を払えなかったら、スターバックスはどう対応するか？　飲み物がすでに出来上がっていたら捨ててしまうだろうし、まだだったらカップを「キュー」から戻すだろう。もし間違った飲み物を出してしまったり、なにか不都合があったりした場合は、新たに作り直すだろう。もし機械が壊れて飲み物を作れなくなってしまったら、お客にお金を払い戻すだろう。こうしたシナリオのそれぞれが、各々異なってはいるが一般的な例外処理の戦略を物語っている：

  * *帳消し（Write-off）* ― 例外処理戦略の中で、一番簡単なものだ。つまり、なんにもしない。あるいは、すでにやっていたものを破棄してしまう。一見ひどい案のようにも思えるが、現実のビジネスではこの選択肢で許容できることもある。損失が少ない場合には、エラーから回復する方法を組み立てる方が、単に諦めるよりよっぽどコストが掛かることもある。たとえば、私はISPプロバイダ数社で仕事をしたことがあるが、そこでは請求／プロビジョニング（設備提供）のサイクルの中でエラーがあったときに、このアプローチを採用することがあった。その場合、顧客はまともにサービスを利用しながら、なんの請求も課されないで済む。失う利益が少なかったため、そうしたビジネスのやり方で問題がなかったのだ。一定の間隔で問題調整レポートを発行して、「無料の」アカウントを発見したらそれを無効にするだけでよかった。

  * *やり直し（Retry）* ― ある大きな処理のまとまり（「トランザクション」のような）の一部分だけが失敗したときは、基本的に2つの選択肢がある。成功した処理をすべて取り消すか、失敗した処理だけをやり直すか。もう一度やり直せば処理が成功する可能性が現実的に考えてあるのであれば、やり直しがふさわしい選択肢になる。たとえば、ビジネスルールに対する違反があった場合、やり直したとしても成功する可能性は薄い。しかし、外部システムに繋がらないといったような場合、やり直すことで成功する可能性が十分にある。やり直しの特殊なケースに [http://www.eaipatterns.com/IdempotentReceiver.html Idempotent Receiver] がある。この場合は、単純にすべての処理をやり直すだけでいい。なぜなら、処理が成功した場合に、受信側は重複メッセージを無視してくれるからだ。

  * *補償行為（Compensating Action）* ― 最後の選択肢は、これまでに完了した処理をすべて取り消して、システムを正常な状態に戻す方法だ。このような「補償行為」は、たとえば金融システムで、いったん請求したお金を払い戻すような場合に有効だ。

これらの戦略はみな、2フェーズコミットとは違うものだ。2フェーズコミットは、準備／実行のステップを分割して行う。スターバックスの例で2フェーズコミットをやってみると、まず飲み物が出来上がるまで、レジの前でレシートとお金をテーブルに置いたまま待つことになる。それから、飲み物が出来上がってきて、同じくレジの前に置かれる。最後に、お金、レシート、飲み物が一瞬のうちに交換される。レジの店員もお客も、「トランザクション」が完了するまではその場を離れられない。こんな2フェーズコミットのアプローチを採用しようものなら、スターバックスのビジネスは間違いなく息の根を止められることになるだろう。というのも、一定時間内に給仕できる顧客数が劇的に減少してしまうからだ。次のことは、よく憶えておくべきだ。2フェーズコミットは物事を大いに単純化してくれるのだが、同時にメッセージの自由な流れ（と結果としてスケーラビリティ）を制限することにもなる。非同期に活動する複数の流れを遮って、状態をもったトランザクション資源を保持しなければならないからだ。

== 対話 (Conversations) ==

コーヒーショップでのやり取りは、[http://www.eaipatterns.com/ramblings/09_correlation.html Conversation] パターンのシンプルだけれども一般性のある好例にもなっている。2つのパーティ（お客とコーヒーショップ）間の相互作用は、短い同期的な相互作用（注文と支払い）と長い非同期の相互作用（飲み物の作成と受け取り）から構成される。このタイプの対話は、何かを購入しようとするシナリオの中で、非常によく見られるのだ。たとえば、Amazonで本を注文するときは、短い同期的な相互作用の中で注文番号を割り当てて、残りのすべてのステップ（クレジットカードへの請求、商品の梱包、発送）は非同期的に行われる。残りのステップが完了した時点で、電子メールで通知（非同期）がなされる。なにか問題が起こったら、Amazonはたいていの場合、補償をする（クレジットカードへ返金する）かやり直す（紛失した商品を再送する）ことで対応する。

最後にまとめると、現実世界はけっこう非同期で動いていることが分かる。私たちの日常生活の多くの部分は、協調こそ必要だが非同期に行われる相互作用（電子メールを読んで返事を書いたり、コーヒーを買ったりなど）で成り立っている。つまり、こうした種類の相互作用をモデリングするには、非同期メッセージングのアーキテクチャが自然な手段になりうることを意味している。また、日常生活を見ていく中から、メッセージングによる上手な解決法を設計するヒントが見出せる、とも言えるのだ。ドモ　アリガトウ　ゴザイマス！