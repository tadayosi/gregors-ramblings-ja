#summary "同期的な非対称 とか 非同期的な対称"って言ってごらん。
#labels 翻訳中
 
= "同期的な非対称 とか 非同期的な対称" って言ってごらん。 =

(原文)http://www.eaipatterns.com/ramblings/26_symmetry.html

== 同期的な非対称(Synchronous Asymmetry) ==
呼びだしスタックは、あるメソッド"caller"がある他のメソッド"callee"を呼びだすという点で本質的に非対称だ。この時、calleeが実行中の間はcallerは処理を中断していて、calleeの実行が完了すると処理はcallerに戻る。calleeの処理が完了した直後にcallerの処理が確実に続行する事を保証するのが呼び出しスタックだ。また、このcallerとcalleeの非対称性はUMLの表記法にも表われている。

http://www.eaipatterns.com/img/symmetry_callstack.gif

メソッドの呼びだしは実線で描かれ、戻り値は在る場合と無い場合があるが、もしあるなら点線で描かれる。また、仮想計算機やプロセッサレベルでもpush/popペアやcall/retペアという形で非対称性が表われている。このように、メソッドを呼びだしたり、サブルーチンを呼び出したりする事は、メソッドやサブルーチンから値を戻す事とは本質的に違う事なのだ。

== 非同期的な対称(Asynchrnous Symmetry) ==
分散システムの世界では、状況はちょっと違う。分散システムでは結局のところ単方向のデータストリーム(しばしば"ソケット"としてアプリケーションに提供される)を通してしか通信できない。スタックをもっと深いところまで見ていけば、システム間の通信はパケットを通して行われているとか、もっと言えばケーブル上の電圧の変化を通して通信しているというという事になるだろう。どちらにせよメソッドの呼びだしも、結果の戻りもデータストリーム上で行う必要があるという事だ。よって、リモート通信に参加している各コンポーネントは、データストリームとオブジェクトを相互に変換できるような送信モジュールと受信モジュールをそれぞれ備えている必要がある。

面白いところは、この事実を対称的に捉える事が、メソッドの呼びだしと戻りという非対称性を解決する解になるという点だ。例えば、次の図では、どちらのコンポーネントがどちらを呼びだしているのだろうか？

http://www.eaipatterns.com/img/symmetry_messaging.gif

この図は左から右へ、もしくは上から下へ描かれているように見えるかもしれないが、どんな文化的な前提があるにせよ(これは大陸を越えると変わる傾向がある)、この図が本質的に対称であることはすぐに分かるだろう。callerもcalleeも両方ともメッセージを送受信するという事だ。唯一の違いと言えば、通常callerが先にメッセージを送信し、後でメッセージを受信する一方、calleeは最初にメッセージを受信し、後からメッセージを送信するという点くらいだ。それ以外はcallerとcalleeにほとんど違いは無い。

あるメッセージがメソッド呼びだし("request"メッセージ)であるか、戻り("response"メッセージ)であるかは、通常は、そのメッセージ自身の名前かもしくは、[http://www.eaipatterns.com/CorrelationIdentifier.html Correlation Identifier]としての役割りを果す<relates-to>要素によって識別される。サービス指向アーキテクチャとウェブサービスwith SOAP over HTTPを同一視する人にとっては、このrequest-responseモデルはHTTPプロトコルで上手く実現できると思うだろう。すなわち、出ていくもの全てが"request"で、戻ってくるもの全てが"response"というわけだ。この考えはクライアント側からの視点、すなわちサービスの利用者側の視点、で考える限りうまく行っている。逆にサービス提供側から見れば、入ってくるもの全ては"request"であり、出ていくもの全ては"responce"となっている。全然対称に聞こえないって？OK。説明しよう。クライアントは接続(コネクション)を開いてから閉じるが、これは結局データストリームの出力・入力で実現されている。また、定常的に動作しているサービスにおいてcall-backモデルを考えれば、サーバーは、クライアントに対して接続(コネクション)を開き、結果を送信している事がわかる。このように考えると、誰がcallerで誰がcalleeだろうか？混乱してきたって？そうだな。これではこの手のシステムを考えるのにちょっと無理があるからだろうか。

== もう一歩先(One Step Further) ==

この対称性は、同期的なオブジェクト指向の世界からネットワーク上の非同期的なデータストリームの世界へ変換する部分を詳しく見てみることで、より明らかになる(図参照)。

http://www.eaipatterns.com/img/symmetry_pipelines.gif

ワイヤー(ネットワークケーブル)にあるオブジェクトを送り出す端点には何が必要だろう？
典型的にはシステム依存のヘッダ要素、たとえばWS-AddressingのようなSOAPヘッダとか、
もしかしたら、セキュリティ証明書などの必要な要素が追加されるかもしれない。そして、最終的にはデータストリームへシリアライズされているだろう。ストリームは暗号化するかもしれない。

では受信する端点ではどうなっているだろう。これはほとんど鏡像のようなものだ。まず最初にデシリアライズし、適用可能な証明書をチェックし、ヘッダをパースしてデータを使用可能な状態にする。そのデータが"request"だろうと"response"だろうと、それは二の次なのだ。レスポンスメッセージを送る時も、ヘッダを追加し、シリアライズし、セキュリティを確保したりする必要があるのだ。これらの機能は基本的には[http://patternshare.org/default.aspx/Home.PP.InterceptingFilter Intercepting Filters]の連鎖で実装されるし、これは結局メッセージングシステムの基礎となる
[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]のパターンといえる。

よって、システム間の相互作用をメッセージの交換と捉える事がとても意味あることだというのが分かったと思う。システムはほとんどがメッセージ送信者とメッセージ受信者である。ほんの少数の高レベルなindicator(ヘッダフィールドなど)だけが、どのシステムが"client"または"caller"か、どのシステムが"server"または"callee"かを特定するにすぎない。全てがメッセージを介して通信するというモデルは、コードの再利用性を促進するだけでなく、よりシンプルなシステム設計を可能にするのだ。

== 例(Examples) ==
数多くのベンダーが同じ結論に達し、ウェブサービス製品をメッセージングの方向に移行しているのを見るのはとても良いことだ。そのなかでもマイクロソフトは良い例を作っている。元々のASP.NET Web Services フレームワークは"SOAPを介してどのようにして自分のメソッドを呼べばいいの？"という問に始終している一方、最近のWeb Services Enhancements(WSE)は完全に!SoapSenderと!SoapReceiverモデルに基づいている。そう、WSEは!SoapClientと!SoapServerというクラスを含んでいるが、それらは実は!SoapSender,!SoapReceiverを継承しているのだ。"clients"も"servers"も両方とも、入出力メッセージでWS-AddressingとWS-Securityをサポートするために、同じ入力フィルターと出力フィルターを使っている。

もし、もう少し時代を進めて見たいのならば、マイクロソフトの分散システムに対する戦略が"メッセージング"に集中していることが簡単にわかるだろう。Indigoはすべてがメッセージングだ。

== 結論(Conclusion) ==

呼びだしスタックの概念は、一つのアドレス空間内に存在するような、同期かつオブジェクト指向なアプリケーションにとっては非常に有用だ。しかし、分散システムを構築しようとするとき、呼びだしスタックの概念は私達に付き纏い、メッセージの送受信という本来のシステム構造を作れなくしてしまう。メッセージベースの非同期性によって、私達を多くの複製(duplication)や悲劇(grief)から救う対称性を達成することができるのだ。