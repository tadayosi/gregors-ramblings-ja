#summary "同期的な非対称 とか 非同期的な対称" とかって言える？
#labels 翻訳中
 
= "同期的な非対称 とか 非同期的な対称" とかって言える？ =

(原文)http://www.eaipatterns.com/ramblings/26_symmetry.html

== 同期的な非対称(Synchronous Asymmetry) ==
呼びだしスタックは本質的に非対称だ。あるメソッド"caller"がある他のメソッド"callee"を呼びだす。calleeが実行中の間はcallerは処理を中断していて、calleeの実行が完了すると処理はcallerに戻る。呼び出しスタックはcalleeの動作が終了した直後にcallerの処理が確実に続行する事を保証するものだ。このcallerとcalleeの非対称性はUMLの表記法にも表われている。

http://www.eaipatterns.com/img/symmetry_callstack.gif

メソッドの呼びだしは実線で描かれ、戻り値はオプションで、もしあるなら点線で描かれる。仮想計算機やプロセッサレベルの非対称性はpush/popやcall/retペアという形で表われる。メソッドを呼びだしたり、サブルーチンを呼び出したりする事は、メソッドやサブルーチンから戻す事とは本質的に違うのだ。

== 非同期的な対称(Asynchrnous Symmetry) ==
分散システムの世界では、状況はちょっと違う。分散システムでは結局のところ単方向のデータストリーム(しばしば"ソケット"としてアプリケーションに提供される)を通してしか通信できない。もしスタックのディープなところまで踏み込みたいなら、????(If you want to dive deeper down the stack, you could also make the claim that they can only communicate via packets or voltage sequences on some sort of wire.)。どちらにせよメソッドの呼びだしも、結果の戻りもデータストリーム上で行う必要がある。よって、リモート通信に参加している各コンポーネントは、データストリームとオブジェクトを相互に変換できるような送信モジュールと受信モジュールを備えている必要がある。

面白いところは、この事実を対称的に捉える事がその非対称性を解決する解になるところだ。例えば、次の図では、どちらのコンポーネントがどちらを呼びだしているのだろうか？

http://www.eaipatterns.com/img/symmetry_messaging.gif

この図は左から右へ、もしくは上から下へ描かれているように見えるかもしれないが、どんな文化的なヒントが潜んでいるにせよ(これは大陸を越えると変わる傾向がある)、この図が本質的に対称であることがすぐに分かるだろう。callerもcalleeも両方ともメッセージを送信・受信する必要がある。唯一の違いは、通常callerが先にメッセージを送信し、後でメッセージを受信する一方、calleeは最初にメッセージを受信し、後からメッセージを送信するという点だ。それ以外はcallerとcalleeにほとんど違いは無い。


The fact that one message is the method call (i.e., the "request" message) and the other one is the return (i.e., the "response" message) often manifests itself only in naming conventions or the presence of a <relates-to> element in the reply message that acts as a Correlation Identifier. Some people who equate service-oriented architectures with Web services and Web services with SOAP over HTTP might feel that the request-response model is nicely represented in the HTTP protocol: everything that "goes out" is a request and everything that "comes back" is a response. That works as long as you look it from the perspective of a client , i.e. a consumer of services. For the service provider everything that "comes in" is a request and everything that "goes out" is a response. Sounds pretty symmetric doesn't it? OK, the "client" gets to open and close the connection but once that is done we are back to "data stream out, data steam in". Besides, once you move to a call-back model for long-running services, the "server" now opens a connection to the "client" to deliver the "result" message. Who is now the caller and who is the callee? Sounds confusing? Well, yeah, because this is not the right way to think about these kinds of systems.

== もう一歩先(One Step Further) ==

この対称性は、同期的なオブジェクト指向の世界からネットワーク上の非同期的なデータストリームの世界へ変換する部分を詳しく見てみることで、より明らかになる(図参照)。

http://www.eaipatterns.com/img/symmetry_pipelines.gif

ワイヤー(ケーブル)にオブジェクトを取り出すには何が必要だろう？
典型的にはシステム依存のヘッダ要素、たとえばWS-AddressingのようなSOAPヘッダを挙げるだろう。
もしかしたら、セキュリティ証明書などの必要な要素を追加して、最終的にデータストリームへシリアライズするかもしれない。ストリームを暗号化するかもしれない。

受信する端点では、ほとんど鏡像のようなものだ。まず最初にデシリアライズし、適用可能な証明書をチェックし、ヘッダをパースしてデータを使用可能な状態にする。そのデータが"request"だろうと"response"だろうと、それは二の次なのだ。レスポンスメッセージを送る時も、ヘッダを追加し、シリアライズし、セキュリティを確保したりする必要がある。これらの機能は基本的には[http://patternshare.org/default.aspx/Home.PP.InterceptingFilter Intercepting Filters]の連鎖で実装されるし、これは結局メッセージングシステムの基礎となる
[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]のパターンなのだ。

よって、

Therefore, it makes a lot more sense to think about the interaction between the systems as an exchange of messages. The systems are primarily message senders and message receivers. Only a few higher level indicators (such as header fields) indicate which system is the "client" or "caller" and which system is the "server" or "callee". Thinking about the messages first allows for better code reuse and ultimately a simpler system model.
Examples

It is nice to see that a number of vendors have come to the same conclusion and are steering their Web services products into the direction of messaging. Microsoft makes for a good example. While the original ASP.NET Web Services framework was all about "how can I call my method over SOAP?", the more recent Web Services Enhancements (WSE) are completely based on a SoapSender and SoapReceiver model. Yes, they also include SoapClient and SoapServer classes but these are actually inherited from the SoapSender and SoapReceiver classes. Both "clients" and "servers" use the same input filter and output filter chain to provide support for WS-Addressing and WS-Security for inbound and outbound messages.

If you look a little bit further down the (time)line you'll easily notice that Microsoft's distributed systems strategy has "messaging" written all over it. Indigo is all about messaging.

== 結論(Conclusion) ==

A call stack mentality is very useful for synchronous, object-oriented applications that live in a single address space. However, when it comes to building distributed systems, the call stack mentality haunts us and makes us not realize the real structure of the system: sending and receiving messages. With message-based asynchrony we achieve symmetry that can save us a lot of duplication and grief.