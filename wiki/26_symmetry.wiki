#summary "同期的な非対称 とか 非同期的な対称" とかって言える？
#labels 翻訳中
 
= "同期的な非対称 とか 非同期的な対称" とかって言える？ =

(原文)http://www.eaipatterns.com/ramblings/26_symmetry.html

== 同期的な非対称(Synchronous Asymmetry) ==
呼びだしスタックは本質的に非対称だ。あるメソッド"caller"がある他のメソッド"callee"を呼びだす。calleeが実行中の間はcallerは処理を中断していて、calleeの実行が完了すると処理はcallerに戻る。呼び出しスタックはcalleeの動作が終了した直後にcallerの処理が確実に続行する事を保証するものだ。このcallerとcalleeの非対称性はUMLの表記法にも表われている。

http://www.eaipatterns.com/img/symmetry_callstack.gif

メソッドの呼びだしは実線で描かれ、戻り値はオプションで、もしあるなら点線で描かれる。仮想計算機やプロセッサレベルの非対称性はpush/popやcall/retペアという形で表われる。メソッドを呼びだしたり、サブルーチンを呼び出したりする事は、メソッドやサブルーチンから戻す事とは本質的に違うのだ。

== 非同期的な対称(Asynchrnous Symmetry) ==
分散システムの世界では、状況はちょっと違う。分散システムでは結局のところ単方向のデータストリーム(しばしば"ソケット"としてアプリケーションに提供される)を通してしか通信できない。もしスタックのディープなところまで踏み込みたいなら、????(If you want to dive deeper down the stack, you could also make the claim that they can only communicate via packets or voltage sequences on some sort of wire.)。どちらにせよメソッドの呼びだしも、結果の戻りもデータストリーム上で行う必要がある。よって、リモート通信に参加している各コンポーネントは、データストリームとオブジェクトを相互に変換できるような送信モジュールと受信モジュールを備えている必要がある。

面白いところは、この事実を対称的に捉える事がその非対称性を解決する解になるところだ。例えば、次の図では、どちらのコンポーネントがどちらを呼びだしているのだろうか？

http://www.eaipatterns.com/img/symmetry_messaging.gif

この図は左から右へ、もしくは上から下へ描かれているように見えるかもしれないが、どんな文化的なヒントが潜んでいるにせよ(これは大陸を越えると変わる傾向がある)、この図が本質的に対称であることがすぐに分かるだろう。callerもcalleeも両方ともメッセージを送信・受信する必要がある。唯一の違いは、通常callerが先にメッセージを送信し、後でメッセージを受信する一方、calleeは最初にメッセージを受信し、後からメッセージを送信するという点だ。それ以外はcallerとcalleeにほとんど違いは無い。


The fact that one message is the method call (i.e., the "request" message) and the other one is the return (i.e., the "response" message) often manifests itself only in naming conventions or the presence of a <relates-to> element in the reply message that acts as a Correlation Identifier. Some people who equate service-oriented architectures with Web services and Web services with SOAP over HTTP might feel that the request-response model is nicely represented in the HTTP protocol: everything that "goes out" is a request and everything that "comes back" is a response. That works as long as you look it from the perspective of a client , i.e. a consumer of services. For the service provider everything that "comes in" is a request and everything that "goes out" is a response. Sounds pretty symmetric doesn't it? OK, the "client" gets to open and close the connection but once that is done we are back to "data stream out, data steam in". Besides, once you move to a call-back model for long-running services, the "server" now opens a connection to the "client" to deliver the "result" message. Who is now the caller and who is the callee? Sounds confusing? Well, yeah, because this is not the right way to think about these kinds of systems.

== もう一歩先(One Step Further) ==

この対称性は、同期的なオブジェクト指向の世界からネットワーク上の非同期的なデータストリームの世界へ変換する部分を詳しく見てみることで、より明らかになる(図参照)。

http://www.eaipatterns.com/img/symmetry_pipelines.gif

ワイヤー(ケーブル)にオブジェクトを取り出すには何が必要だろう？
典型的にはシステム依存のヘッダ要素、たとえばWS-AddressingのようなSOAPヘッダを挙げるだろう。
もしかしたら、セキュリティ証明書などの必要な要素を追加して、最終的にデータストリームへシリアライズするかもしれない。ストリームを暗号化するかもしれない。

受信する端点では、ほとんど鏡像のようなものだ。まず最初にデシリアライズし、適用可能な証明書をチェックし、ヘッダをパースしてデータを使用可能な状態にする。そのデータが"request"だろうと"response"だろうと、それは二の次なのだ。レスポンスメッセージを送る時も、ヘッダを追加し、シリアライズし、セキュリティを確保したりする必要がある。これらの機能は基本的には[http://patternshare.org/default.aspx/Home.PP.InterceptingFilter Intercepting Filters]の連鎖で実装されるし、これは結局メッセージングシステムの基礎となる
[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]のパターンなのだ。

よって、システム間の相互作用をメッセージの交換と捉える事が意味あることなのがわかると思う。システムはほとんどがメッセージ送信者とメッセージ受信者である。ほんの少数の高レベルなindicator(ヘッダフィールドなど)だけが、どのシステムが"client"または"caller"か、どのシステムが"server"または"callee"かを特定する。Thinking about the messages first allows for better code reuse and ultimately a simpler system model.

== 例(Examples) ==
数多くのベンダーが同じ結論に達し、ウェブサービス製品をメッセージングの方向に移行しているのを見るのはとても良いことだ。そのなかでもマイクロソフトは良い例を作っている。元々のASP.NET Web Services フレームワークは"SOAPを介してどのようにして自分のメソッドを呼べばいいの？"という問に始終している一方、最近のWeb Services Enhancements(WSE)は完全にSoapSenderとSoapReceiverモデルに基づいている。そう、WSEはSoapClientとSoapServerというクラスを含んでいるが、それらは実はSoapSender,SoapReceiverを継承しているのだ。"clients"も"servers"も両方とも、入出力メッセージでWS-AddressingとWS-Securityをサポートするために、同じ入力フィルターと出力フィルターを使っている。

もし、もう少し時代を進めて見たいのならば、マイクロソフトの分散システムに対する戦略が"メッセージング"に集中していることが簡単にわかるだろう。Indigoはすべてがメッセージングだ。

== 結論(Conclusion) ==

呼びだしスタックの概念は、一つのアドレス空間内に存在するような、同期かつオブジェクト指向なアプリケーションにとっては非常に有用だ。しかし、分散システムを構築しようとするとき、呼びだしスタックの概念は私達に付き纏い、メッセージの送受信という本来のシステム構造を作れなくしてしまう。メッセージベースの非同期性によって、私達を多くの複製(duplication)や悲劇(grief)から救う対称性を達成することができるのだ。