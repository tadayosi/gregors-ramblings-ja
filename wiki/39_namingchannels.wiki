#summary 名前がいったい何だというの？
#labels 翻訳中

= 名前がいったい何だというの？ =
（原文） http://www.eaipatterns.com/ramblings/39_namingchannels.html

2006年3月5日

_訳注1: 「名前がいったい何だというの？（What's in a name?）」はシェイクスピア『ロミオとジュリエット』の有名な台詞。_

== 新しい要素 (A New Element) ==

[http://www.eaipatterns.com/img/simplemessaging.png]

メッセージング・ベースの相互作用では、2つの新しい要素が導入される。チャンネルとメッセージだ。この2つの新要素そのものは単純なのだが、選択肢の幅が広がるので、新しい決断を求められる。一見簡単そうだが注意を要するのは、「チャンネルにどんな名前を付けるか？」という問題だ。メソッドが別のメソッドを直接呼ぶだけだった時代には、媒介する要素が間に何もなかったので、何も決めなくてよかった。今や、われわれは新しいレベルの間接性を手にしてしまったので、それに適切な名前を付けなければならないのだ。さて選択、選択・・・

== 単なる名前以上のもの (More Than Just a Name) ==

チャンネルに適切な名前を見つけるには、まずそのチャンネルが何を表現するものなのかを決める必要がある。チャンネルは純粋に論理的な構成物といえるようなものにも関わらず、送信者と受信者とを結びつける重要なメカニズムである。メッセージの交換を行なうためには、メッセージの送信者と受信者の両方が、共通のチャンネル名について合意しなければならない。

Let's look at a few obvious choices:

すぐに思い浮かぶ選択肢のいくつかを見てみよう。

 * 非常に単純なアプローチは、コンポーネント毎にチャンネルを割り当てるというものだ。たとえば、クレジットカードの検証を行なうコンポーネントを `CreditService` と呼ぶことにし、同じく `CreditService` と名付けられたチャンネルに送信されたメッセージに対して応答するものとする。クレジットに関係する何かが必要なコンポーネントは、みなこのチャンネルにメッセージを送信することになる。この単純なアプローチでも、実装レベルではある一定の間接性が実現される。チャンネル名さえ変えなければ、誰にも気付かれずにクレジットサービスの実装を別のものに置き換えることが可能だからだ。しかし、その相互作用の意味論的機構は、それほど疎結合になっていない。呼び出す側は、未だにどのコンポーネントが求める機能を提供しているかを知っていなくてはならないからだ。これでは、コンポーネント同士が直接、一対一の相互作用をする場合とほとんど同じである。

 * To reduce the dependency on a specific service we could name the channel analogous to a method name, i.e. according to the operation that is to be performed. For example, if the service provided an operation that can verify a credit card supplied by a customer we might simply name the channel VerifyCreditCard. It is important to keep in mind that these channel operations are not tied to a specific class as is the case in object-oriented approaches. As a result, the caller no longer has to know which component is able to service this type of request, increasing the level of abstraction somewhat. Service-oriented computing generally follows this approach with the only caveat that the operation is typically tied to a specific service (interface).

 * 特定のサービスへの依存を減らすために、メソッド名にちなんだ名前をチャンネルに付けてもよい。メソッド名とは、すなわちそこで実現される操作のことだ。

 * Despite the introduction of the channel the semantics of the interaction between the two components still smells a little like a call stack-based system: One component sends a specific request (“check this credit card”) and expects a response (“card good” or “card bad”). But don't despair, we have not yet exhausted the creative possibilities of the channel semantics. Both examples above assume that the requesting component knows that a credit card has to be verified. Could we lift this burden from the “caller” altogether so that the components are truly decoupled? We can take the decoupling one step further by changing the channel name (and the associated semantics) to OrderReceived. This simple change in name signifies a fairly significant shift in responsibility. The message on the channel no longer represents an instruction but rather an event, a notification that something happened. How a receiver responds to this event is completely hidden to the sender. We also no longer assume that there is a single recipient for the event -- the event might be processed by more than one subscriber. For example, a new order not only has to go through credit checking but inventory might also have to be verified. Again, the assumptions between the communicating parties have been reduced. As a result, EDA is often considered to be more loosely coupled than SOA.

 * チャンネルを導入したにも関わらず、これではまだ2つのコンポーネント間の相互作用の意味論的機構は、呼び出しスタック・ベースのシステムと同じ臭いがする。あるコンポーネントが特定の要求（「このクレジットカードを確認せよ」）を送信し、応答（「良いカード」または「悪いカード」）を期待する、というものだからだ。

[http://www.eaipatterns.com/img/channelnames.png]

== 責務の遷移 (Shifting Responsibilities) ==

Communicating through events as opposed to commands indicates a subtle but important shift of responsibility. It allows components to be decoupled to the extent that the “caller” is no longer aware of what function is executed next nor which component is executing it. Another equally important shift of responsibility between caller and callee is that of keeping state.

In a system that is based on queries and commands state is usually kept in one application that is considered the “master” for the data. When another application needs to reference that data it sends a query to the owning application and waits for the response before it continues processing. For example, when an order management system needs to fulfill an order it queries the customer management systems for the customer’s address so it can instruct the shipping application to send the shipment to that address.

[http://www.eaipatterns.com/img/statetransfer1.png]

Event-driven systems work differently, almost to the inverse. Systems do not query other systems for information but instead keep their own copy of the required data and listen to updates as they occur. In our example this would mean that the shipping system keeps its own copy of the customer’s address so when an order arrives it can use that address to label the shipment without having to query the customer management system. While replicating data this way might seem dangerous it also has advantages. The customer management system simply broadcasts changes to the data without having to know who all keeps a copy. Because the customer management is never queried for address data it never becomes a bottleneck even as the system grows and the demands for address data multiply.

The principle behind the shift in responsibility is once again tied to the concept of coupling. In a loosely coupled interaction a source of data should not be required to keep state at the convenience of its communication partners. By shifting the burden of keeping state to the consumer the component is can be completely oblivious to the needs of the data consumers – the key ingredient into loose coupling. The shift away from the query-response pattern of interaction means that many components have to act as event Aggregators: they listen to events from multiple sources, keep the relevant state and combine information from multiple events into new events. For example, the shipping system effectively combines address change events and order events into request for shipment to a specific address.

[http://www.eaipatterns.com/img/statetransfer2.png]

== 問題点 (The Catch) ==

It sounds like event-based systems surpass command-and-control systems across the architectural "score card". They are more loosely coupled and allow free composition of individual components into a larger system, thus aiding reuse and flexibility. Additionally, they can provide a natural mapping of a problem space into the system model. After all, many interactions in the real world are based on events. So are non-event-based systems for losers? Not quite -- as always, there is not free lunch, at least outside Google. Dynamic, loosely coupled systems are inherently difficult to design and debug (see Good Composers are Far and Few in Between). So we need to make sure to have the right tools at hand (for example, see Visualizing Dependencies) and to gain experience by making mistakes early in a small scale.

イベント・ベースのシステムは、アーキテクチャの「スコアカード」のすべてにおいて、命令－制御型のシステムを上回っているようにも聞こえる。