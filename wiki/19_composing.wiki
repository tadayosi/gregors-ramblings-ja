#summary よい作曲家／構成者はきわめて稀だ
#labels 翻訳中

= よい作曲家／構成者はきわめて稀だ =
（原文） http://www.eaipatterns.com/ramblings/19_composing.html

2004年11月30日

== 結合すべきか、分離すべきか（To Couple or Not to Couple） ==

最近は、結合性についての議論が活発だ。実は、この話題については言いたいことが山ほどあるので、大部分は別のポストに取っておこうと思う。今回は次のことだけに留めておこう。私の考えでは、結合性とはシステム間の依存性を測る指標だ。[http://www.pacificspirit.com/blog/ David Orchard]は、究極の疎結合ソリューションを次のようなナイスな言葉で定義している。「2つのシステムを疎結合にするにはどうすればいいか？　接続しないことだ！」　私が思うに、結合性についてこんなにも議論が白熱する理由の1つは、もともと接続を必ずしも想定していなかったシステム同士を接続することが一般に多い、という現実があるからだ。自然と、議論はどこまでの依存を、したがってどこまでの結合を、システム間に導入すべきかということになる。

悲しいかな、ソフトウェアアーキテクチャにおいて1つの正しい答えがあることは稀で、結合性についても例外ではない。結合を高めれば効率的でシンプルになるが、一方で硬直的で脆弱にもなる。一般に疎結合なアーキテクチャの例として、イベント駆動システム（event-driven system）がある。イベント駆動システムは、入力イベントに応答する独立した処理要素が集まって出来ている。ある処理要素がイベントメッセージを受け取ると、指定の機能を実行して、1つ以上の出力イベントを発行する。その出力イベントは、さらに別の処理ノードが受け取ることもできる。独立した処理要素からより大きな相互接続したシステムを構成することで、完全なソリューションを作り上げるのだ（下図を参照）。

[http://www.eaipatterns.com/img/composing.gif]

== 構成可能性（Composability） ==

構成可能であることの利点の1つは、処理要素をさまざまなシステム群の中で再利用できることだ。再利用が可能なのは、処理要素が互いに直接的な前提を一切もっていないからだ。このことは再利用を助け、将来の要求に対しても柔軟に対応することを可能にする。たとえば、2つの既存ノード間に新たな処理ノードを差し挟むのは非常に簡単だ。しかし、柔軟性にはダークサイドもある（[http://www.eaipatterns.com/img/vader.wav ダース・ベイダーの息吹を聞こう]）。柔軟なシステムを作る方法は、システムの構成方法についての制約を緩めることだ。こうすることで、将来の必要に応じてシステムを構成し直すことが可能となる。しかし、これはシステムが提供できるミス発見の手段が、少なくなることも意味する。たとえば、疎結合アーキテクチャとしては完全に妥当なシステムを構成したとしても、それが実際には何もまともな動作をしない、ということがあるかもしれない。たとえば、決して発行されることのないイベントを、処理要素が待ち受けていることもあるかもしれない。あるいは、チャネル上のメッセージ型が、処理要素が想定しているものと一致していないこともあるかもしれない。

== 統合テスト（Integration Testing） ==

As a result, integration testing is more critical than ever with loosely coupled, composable systems. We learned that lesson ourselves on a number of projects. The story goes kinda like this: Each component is thoroughly unit tested (for more on messaging and unit testing see Dependency Injection in Messaging Architectures) and produces the coveted green bar. However, the actual system exhibits fatal flaws, a popular one being a system that does plain nothing. Most of the time this happens because the individual components were improperly composed. We need to remind ourselves that in most systems 95% of all compositions don't actually do anything useful. However, as far as the flexible architecture is concerned, they are perfectly valid.

その結果、疎結合な、構成可能なシステムでは、統合テストはこれまでにないほど重要である。私たちは、多くのプロジェクトからこの教訓を学んだ。ストーリーはこんな感じだ。それぞれのコンポーネントは十分に単体テストがされていて（メッセージングと単体テストについては[13_ioc メッセージングアーキテクチャにおける依存性注入]を参照）、誰もが望むようなグリーンバーを示している。しかし、実際のシステムは致命的な欠陥を露呈してしまう。システムがビクとも動かない、というよくある奴だ。ほとんどの場合、その原因は個々のコンポーネントが不適切に構成されたからだ。ほとんどのシステムでは、全構成の95%は実際には何ら役に立つことをしていないということを思い出す必要がある。しかし、柔軟なアーキテクチャに関するかぎり、システムの構成はすべて重要なのだ。

This implies that we need to think carefully about validating the composability as well as the actual composition of the individual processing elements. Neither one is a trivial task. Composability implies that individual processing elements do not make any undue assumptions about the actual composition. Often this cannot be validated by traditional testing because composability implies being able to use the component in unforeseen scenarios. Naturally, it is difficult to test explicitly for unforeseen scenarios. Instead, we often have to use code analysis or inspection to make any statements about composability. One of the biggest hindrances to composability are hidden assumptions. Hidden assumptions are often unavoidable but can also introduce a glut of problems. For example, if one component stores data in a central database that is read by another component, we introduced an "out of band" dependency between the two components. The main issue is that this dependency is not explicitly represented anywhere in the system and is often not detected until run-time.

このことは、個々の処理要素を実際に構成することだけでなく、構成可能性を検証することについても、我々は注意深く考えなければならないことを意味している。どちらも簡単なタスクではない。構成可能性というのは、つまり個々の処理要素が実際の構成についてどんな過度の前提も置かない、ということだ。多くの場合、従来のテスト手法では構成可能性を検証することができない。なぜなら構成可能性というのは、コンポーネントを予想していないシナリオでも使えることを意味するからだ。当然、予想できないシナリオを明示的にテストするのは難しい。その代わり、構成可能性について何かを言うならば、たいていはコード分析やインスペクションを行わなければならない。構成可能性に対する最大の障害の1つは、隠れた前提だ。隠れた前提はたいてい回避できないが、さらに溢れんばかりの問題を持ち込みさえする。たとえば、あるコンポーネントが中央データベースにデータを格納して、それが別のコンポーネントから読まれるならば、その2つのコンポーネント間には「帯域外の（out of band）」依存関係が持ち込まれることになる。その主な問題は、この依存関係はシステムのどこにも明示的に表現されておらず、たいていは実行時になるまで発見されないということだ。

== 新しいプログラミングモデル（New Programming Model） ==

Testing the actual composition of the individual elements is another important part of validating the system. This type of testing can be categorized as integration testing and sits in between unit testing and true functional (i.e. user) testing. This type of testing is important to validate that the chosen composition of the individual elements performs the desired functions. It typically does so by channeling test data into the system and comparing actual with expected results. Luckily, loosely coupled systems generally make it quite easy to inject test data so the mechanics of these test are quite simple. However, achieving proper test coverage can be challenging.

個々の要素を実際に構成したものをテストすることは、システムを検証するもう1つの重要な部分だ。このタイプのテストは統合テストとして分類できるもので、単体テストと真の機能（ユーザ）テストとの間に位置する。このタイプのテストでは、選ばれた個々の要素の構成が望ましい機能を実現することを検証するのが重要だ。通常は、システムのチャネルにテストデータを流して、期待される結果と実際とを比較することでテストする。運がいいことに、疎結合のシステムでは一般にテストデータを注入するのがとても簡単なので、こうしたテストの技法はとてもシンプルだ。しかし、適切なだけのテストカバレッジを達成するのもやり甲斐のある仕事になるだろう。

When creating these integration tests we need to be aware that with the introduction of composability we also introduced a new programming model into the application. The compositions follow the rules of a Pipes-and-Filters architecture, not an object-oriented architecture. This means that we deal with different constructs and rules. This requires us to rethink our approach to testing slightly.

こうした統合テストを作成するときには、構成可能性を導入することでアプリケーションに新しいプログラミングモデルも導入してしまっている、ということを意識する必要がある。構成されたシステムは[http://www.eaipatterns.com/PipesAndFilters.html パイプ＆フィルタ]アーキテクチャのルールに従うのであって、オブジェクト指向アーキテクチャではない。それはつまり、異なる構成物やルールを扱っているということだ。テストに対する我々のアプローチに、少しばかり再検討が求められるのだ。

== 妥当性検証ルール（Validation Rules） ==

Testing in the traditional sense will only perform part of the necessary validation. The reason for this is that in traditional programming models (for example, object-oriented programming) the compiler already validates a lot of the rules inherent in the programming model. For example, syntax errors, referencing an object before creating it etc. Because the composition layer follows our own rules, we often need to create our own validations. For example, is it valid to have loops? Is it valid to subscribe to an event that is never published? Is it valid to publish an event that no one subscribes to? Is it valid to have multiple subsystems that communicate amongst themselves but not between each other?

従来的な意味でのテストでは、必要な妥当性検証の一部分しか実行されないだろう。その理由は、従来のプログラミングモデル（たとえばオブジェクト指向プログラミング）では、コンパイラがそのプログラミングモデル固有のルールの多くをすでに検証してくれているからだ。たとえば、構文エラー、生成前にオブジェクトを参照してしまっていること、などだ。構成層（composition layer）は我々自身が決めたルールに従うので、たいてい我々自身で妥当性検証をやらなくてはいけないのだ。たとえば、ループをもつことは妥当なのか？　決して発行されないイベントを待ち受けることは妥当なのか？　誰も待ち受けていないイベントを発行することは妥当なのか？　自分自身とだけ通信して、互いに通信し合わない複数のサブシステムをもつことは妥当なのか？

It is very useful to have means of inspecting the composition to execute these validation rules automatically. Because we can typically represent pipes-and-filters systems as a directed graph we can often draw on simple graph algorithms to perform these validations. The key is to consolidate information about event publishing and event subscription into a simple, central repository of sorts. That can preferably occur at design time or alternatively at run-time (for example, through a Control Bus). The importance of such validations is underlined by the fact that many architects consider the ability to perform automated analysis a key characteristic of an architectural style (for example, see Stylized Architecture, Design Patterns, and Objects ). Once the architectural style is expressed more formally, one can envision actual languages that can help express the desired constraints. This might in fact be useful in larger systems. Alternatively, we can translate the system structure into a more familiar syntax (for example, XML) and the use languages such as XPATH to execute the desired validations.

これらの妥当性検証ルールを自動実行するための、構成検査の手段をもつことはとても有益だ。通常、パイプ＆フィルタ型システムは有向グラフとして表すことができるため、妥当性検証を行うのにたいてい簡単なグラフアルゴリズムを利用することができる。ポイントは、イベント発行とイベント受信に関する情報を、単純な中心リポジトリのようなものに一元化することだ。この作業はできれば設計時に行いたいが、実行時に行ってもよい（たとえば、[http://www.eaipatterns.com/ControlBus.html Control Bus]を通して）。このような妥当性検証が重要であることは、自動化された分析を行えることがアーキテクチャスタイルのキーとなる性質だと、多くのアーキテクトが考えている事実により強調される（たとえば、[http://www-2.cs.cmu.edu/afs/cs/project/compose/ftp/pdf/ObjPatternsArch-ieee97.pdf アーキテクチャスタイル、デザインパターン、オブジェクト]を参照）。いったんアーキテクチャスタイルがより形式的に表現されれば、望ましい制約の表現に役立つ現実的な言語を思い描くことができる。こうした言語は、大きなシステムでは実際に役立つだろう。別の方法として、システムの構造をもっと馴染みのある構文（たとえばXML）に変換することもできる。そして、XPATHのような言語を使って望ましい妥当性検証を実行するのだ。

A less formal form of analysis is a visualization of the resulting system, for example as described in an earlier blog entry. In this case, the validation is only half automated because we use human beings to assess whether the composition is a good one or not. However, the system automatically preprocesses the information such that it is easily understood by human beings. This approach often turns out to be a quite reasonable compromise.

より形式的でない形の分析方法に、出来上がったシステムを可視化する方法がある。たとえば、[11_dependencies 以前のブログエントリ]で書いたものだ。この場合、妥当性検証は半分だけしか自動化されていない。なぜなら、その構成がグッドかそうでないかを人間が評価するからだ。しかし、システムが自動的に、人間が簡単に理解できるような形の情報に前処理してくれる。このアプローチは、たいていやってみると非常に理にかなった妥協案だと分かる。

== まとめ（Conclusion） ==

Building loosely coupled and composable systems have definite advantages. However, we have to keep in mind that such architectures introduce an additional layer, the composition layer, into the system. This layer has to be understood and tested separately as it often follows different architectural styles and design principles than the other layers.

疎結合で構成可能なシステムを構築することには、明らかな利点がある。しかし、そのようなアーキテクチャはシステムに構成層という更なる層を導入することを、覚えておかなければならない。この層は別個に理解したり、テストしたりしなければならない。それは、この層がたいてい他の層とは異なるアーキテクチャスタイルや設計原理に従うものだからだ。