#summary よい作曲家／構成者はきわめて稀だ
#labels 翻訳中

= よい作曲家／構成者はきわめて稀だ =
（原文） http://www.eaipatterns.com/ramblings/19_composing.html

2004年11月30日

== 結合すべきか、分離すべきか（To Couple or Not to Couple） ==

There is a lot of debate about coupling these days. In fact, there is enough to be said about this topic that I'll leave most of it for a separate posting. Let it suffice to say that in my opinion coupling is a measure of dependency between systems. David Orchard has given us a nice definition of the ultimate loosely coupled solution by stating: "How do you make two systems loosely coupled? Don't connect them!" I believe one of the reasons we are having so many debates about coupling is due to the fact that we more commonly connect systems that were not necessarily designed to be connected in the first place. Naturally, the resulting debate is how much dependency and hence how much coupling to introduce between the systems.

最近は、結合性についての議論が活発だ。実際、この話題については言いたいことが山ほどあるので、大部分は別のポストに取っておこうと思う。ここでは次のことだけに留めておこう。私の考えでは、結合性とはシステム間の依存性を測る指標だ。[http://www.pacificspirit.com/blog/ David Orchard]は、究極の疎結合ソリューションを次のようなナイスな言葉で定義している。「2つのシステムを疎結合にするにはどうすればいいか？　接続しないことだ！」結合性についてこんなにも議論が白熱する理由の1つとして私が思っているのは、一般的に元々接続することを必ずしも想定していなかったシステム同士を接続することが多いという現実だ。自然と、議論はどれだけの依存を、従ってどれだけの結合を、システム間にもたらすことになるか、ということになる。

Alas, there is rarely one right answer in software architecture and coupling is no exception. More coupling gives us efficiency and simplicity but can also introduce rigidity and brittleness. One example of generally more loosely coupled architectures are event-driven systems. These systems consist of a collection of individual processing elements that respond to incoming events. When a processing element receives an event message it perform its designated function and publishes one or more resulting events. These events can then be picked up by other processing nodes. A complete solution is created by composing the individual processing elements into a larger interconnected system (see figure).

悲しいかな、ソフトウェアアーキテクチャにおいて1つの正しい答えがあることは稀で、結合性についても例外ではない。結合を高めれば効率的でシンプルになるが、硬直的で脆弱にもなる。一般に疎結合なアーキテクチャの一例として、イベント駆動システムがある。イベント駆動システムは、入力イベントに対して応答する独立した処理要素が集まって出来ている。ある処理要素がイベントメッセージを受け取ると、所定の機能を実行して、1つ以上の出力イベントを発行する。そのイベントは、さらに別の処理要素が受け取ることもできる。独立した処理要素から、より大きな相互接続したシステムを組み立てることで、完全なソリューションを構築するのだ（下図を参照）。

[http://www.eaipatterns.com/img/composing.gif]

== 構成可能性（Composability） ==

One of the advantages of composability is that the processing elements can be reused in various constellations because the elements do not make any direct assumptions about each other. This helps with reuse and provides flexibility to support future requirements. For example, it is quite easy to interject a new processing node between two existing nodes. But this flexibility also has a dark side (hear Darth Vader breathe). We built flexibility into the system by loosening the constraints on the system composition. This gives us the ability to recompose the system according to future needs. But this also means that the system has fewer means of detecting our mistakes. For example, we might have composed something that is perfectly valid according to the loosely coupled architecture but that does not actually do anything useful. For example, a processing element may listen for events that are never published. Or, the type of message on a channel might not match what the element expects.

構成可能であることの利点の1つは、処理要素をさまざまなシステム群の中で再利用できることだ。再利用が可能なのは、処理要素が互いに直接的な前提を一切もっていないからだ。このことは再利用を助け、将来の要求に対しても柔軟に対応することを可能にする。たとえば、2つの既存ノード間に新たな処理ノードを差し挟むのはとても簡単だ。しかし、柔軟性にはダークサイドもある（[http://www.eaipatterns.com/img/vader.wav ダース・ベイダーの息吹を聞こう]）。システム内に柔軟性を構築する方法は、システムの構成方法についての制約を緩めることだ。こうすることで、将来の必要に応じてシステムを構成し直すことが可能となる。しかし、これはシステムで提供されるミスを発見するための手段が少ないことも意味する。たとえば、疎結合アーキテクチャとしては完全に妥当なシステムを構成したとしても、それは実際には何もまともなことをしていない、ということがあるかもしれない。またたとえば、処理要素が決して発行されることのないイベントを受信しようとしていることもあるかもしれない。あるいは、チャネル上のメッセージ型が、処理要素が想定しているものと一致していないこともあるかもしれない。

== 統合テスト（Integration Testing） ==

As a result, integration testing is more critical than ever with loosely coupled, composable systems. We learned that lesson ourselves on a number of projects. The story goes kinda like this: Each component is thoroughly unit tested (for more on messaging and unit testing see Dependency Injection in Messaging Architectures) and produces the coveted green bar. However, the actual system exhibits fatal flaws, a popular one being a system that does plain nothing. Most of the time this happens because the individual components were improperly composed. We need to remind ourselves that in most systems 95% of all compositions don't actually do anything useful. However, as far as the flexible architecture is concerned, they are perfectly valid.

その結果、疎結合な、構成可能なシステムでは、統合テストはこれまでにないほど重要である。私たちは、多くのプロジェクトからこの教訓を学んだ。ストーリーはこんな感じだ。それぞれのコンポーネントは十分に単体テストがされていて（メッセージングと単体テストについては[13_ioc メッセージングアーキテクチャにおける依存性注入]を参照）、誰もが望むようなグリーンバーを示している。しかし、実際のシステムは致命的な欠陥を露呈してしまう。システムがビクとも動かない、というよくある奴だ。ほとんどの場合、その原因は個々のコンポーネントが不適切に構成されたからだ。ほとんどのシステムでは、全構成の95%は実際には何ら役に立つことをしていないということを思い出す必要がある。しかし、柔軟なアーキテクチャに関するかぎり、システムの構成はすべて重要なのだ。

This implies that we need to think carefully about validating the composability as well as the actual composition of the individual processing elements. Neither one is a trivial task. Composability implies that individual processing elements do not make any undue assumptions about the actual composition. Often this cannot be validated by traditional testing because composability implies being able to use the component in unforeseen scenarios. Naturally, it is difficult to test explicitly for unforeseen scenarios. Instead, we often have to use code analysis or inspection to make any statements about composability. One of the biggest hindrances to composability are hidden assumptions. Hidden assumptions are often unavoidable but can also introduce a glut of problems. For example, if one component stores data in a central database that is read by another component, we introduced an "out of band" dependency between the two components. The main issue is that this dependency is not explicitly represented anywhere in the system and is often not detected until run-time.

このことは、個々の処理要素を実際に構成することだけでなく、構成可能性を検証することについても、我々は注意深く考えなければならないことを意味している。どちらも簡単なタスクではない。構成可能性というのは、つまり個々の処理要素が実際の構成についてどんな過度の前提も置かない、ということだ。多くの場合、従来のテスト手法では構成可能性を検証することができない。なぜなら構成可能性というのは、コンポーネントを予想していないシナリオでも使えることを意味するからだ。当然、予想できないシナリオを明示的にテストするのは難しい。その代わり、構成可能性について何かを言うならば、たいていはコード分析やインスペクションを行わなければならない。構成可能性に対する最大の障害の1つは、隠れた前提だ。隠れた前提はたいてい回避できないが、さらに溢れんばかりの問題を持ち込みさえする。たとえば、あるコンポーネントが中央データベースにデータを格納して、それが別のコンポーネントから読まれるならば、その2つのコンポーネント間には「帯域外の（out of band）」依存関係が持ち込まれることになる。その主な問題は、この依存関係はシステムのどこにも明示的に表現されておらず、たいていは実行時になるまで発見されないということだ。

== 新しいプログラミングモデル（New Programming Model） ==

Testing the actual composition of the individual elements is another important part of validating the system. This type of testing can be categorized as integration testing and sits in between unit testing and true functional (i.e. user) testing. This type of testing is important to validate that the chosen composition of the individual elements performs the desired functions. It typically does so by channeling test data into the system and comparing actual with expected results. Luckily, loosely coupled systems generally make it quite easy to inject test data so the mechanics of these test are quite simple. However, achieving proper test coverage can be challenging.

個々の要素を実際に構成したものをテストすることは、システムを検証するもう1つの重要な部分だ。このタイプのテストは統合テストとして分類できるもので、単体テストと真の機能（ユーザ）テストとの間に位置する。このタイプのテストでは、選ばれた個々の要素の構成が望ましい機能を実現することを検証するのが重要だ。通常は、システムのチャネルにテストデータを流して、期待される結果と実際とを比較することでテストする。運がいいことに、疎結合のシステムでは一般にテストデータを注入するのがとても簡単なので、こうしたテストの技法はとてもシンプルだ。しかし、適切なだけのテストカバレッジを達成するのもやり甲斐のある仕事になるだろう。

When creating these integration tests we need to be aware that with the introduction of composability we also introduced a new programming model into the application. The compositions follow the rules of a Pipes-and-Filters architecture, not an object-oriented architecture. This means that we deal with different constructs and rules. This requires us to rethink our approach to testing slightly.

こうした統合テストを作成するときには、構成可能性を導入することでアプリケーションに新しいプログラミングモデルも導入してしまっている、ということを意識する必要がある。構成されたシステムは[http://www.eaipatterns.com/PipesAndFilters.html パイプ＆フィルタ]アーキテクチャのルールに従うのであって、オブジェクト指向アーキテクチャではない。それはつまり、異なる構成物やルールを扱っているということだ。テストに対する我々のアプローチに、少しばかり再検討が求められるのだ。

== 妥当性検証ルール（Validation Rules） ==

Testing in the traditional sense will only perform part of the necessary validation. The reason for this is that in traditional programming models (for example, object-oriented programming) the compiler already validates a lot of the rules inherent in the programming model. For example, syntax errors, referencing an object before creating it etc. Because the composition layer follows our own rules, we often need to create our own validations. For example, is it valid to have loops? Is it valid to subscribe to an event that is never published? Is it valid to publish an event that no one subscribes to? Is it valid to have multiple subsystems that communicate amongst themselves but not between each other?

It is very useful to have means of inspecting the composition to execute these validation rules automatically. Because we can typically represent pipes-and-filters systems as a directed graph we can often draw on simple graph algorithms to perform these validations. The key is to consolidate information about event publishing and event subscription into a simple, central repository of sorts. That can preferably occur at design time or alternatively at run-time (for example, through a Control Bus). The importance of such validations is underlined by the fact that many architects consider the ability to perform automated analysis a key characteristic of an architectural style (for example, see Stylized Architecture, Design Patterns, and Objects ). Once the architectural style is expressed more formally, one can envision actual languages that can help express the desired constraints. This might in fact be useful in larger systems. Alternatively, we can translate the system structure into a more familiar syntax (for example, XML) and the use languages such as XPATH to execute the desired validations.

A less formal form of analysis is a visualization of the resulting system, for example as described in an earlier blog entry. In this case, the validation is only half automated because we use human beings to assess whether the composition is a good one or not. However, the system automatically preprocesses the information such that it is easily understood by human beings. This approach often turns out to be a quite reasonable compromise.

== まとめ（Conclusion） ==

Building loosely coupled and composable systems have definite advantages. However, we have to keep in mind that such architectures introduce an additional layer, the composition layer, into the system. This layer has to be understood and tested separately as it often follows different architectural styles and design principles than the other layers.