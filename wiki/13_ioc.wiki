#summary メッセージングアーキテクチャにおける依存性注入
#labels 翻訳完了

= メッセージングアーキテクチャにおける依存性注入 =
（原文） http://www.eaipatterns.com/ramblings/13_ioc.html

2004年9月3日

== 依存性注入 (Dependency Injection) ==

たくさんの開発者が最近、制御の反転（IoC）と依存性注入について語っている。私は、他の人が十分に説明しつくしたことを、繰り返すつもりはない。依存性注入の背景にある詳しい議論を知りたい人は、[http://www.martinfowler.com/ Martin Fowler]のこの[http://kakutani.com/trans/fowler/injection.html#FormsOfDependencyInjection 記事]か、Aslak HellesoyとPaul Hammant（英国の同僚!ThoughtWorkerたち）によるこの[http://docs.codehaus.org/display/PICO/Inversion+of+Control 投稿]を参照してほしい。ここでは、皆さんが文章をたくさん読まなくて済むように、要点だけを説明しよう（私なりの解釈になるが）。オブジェクトAは、オブジェクトBのサービスを利用したいために、Bへの参照が必要だとする。普通のやり方では、Aが「new」コマンドを用いてBのインスタンスを生成する。AはBへの参照を得るので、そのメソッドを呼び出すことができる。さて、ここまではOO初級講座のレッスンみたいで、面白いところは何もない。しかし、状況に応じて、Aが異なるバージョンのBを必要とするとしたら、どうだろう？　たとえば、Bが永続化サービスを提供するとしよう。テスト時には単にファイルにデータを書き込むだけでいいが、実稼働時は商用データベースを使いたいかもしれない。あるいは、Bがメッセージングサービスを提供するとすれば、単体テスト用には同期型の実装を使い、統合テストと実稼働用には非同期の実装を使いたいかもしれない。あるいは、モックのメッセージング層を使って、実際のメッセージングは行わずに、Aが正しいデータをメッセージング層に投げることだけを確認したいかもしれない。

インタフェースや継承、ポリモーフィズムといったオブジェクト指向の構成要素は、共通するインタフェースの背後に異なる実装を隠す、お馴染みのメカニズムを提供してくれる。これらの構成要素を使うと、Aが共通のインタフェースBを通して、そのサービスにアクセスできる。このとき、インタフェースBの実装は、異なる実装B＊とB’のどちらであってもよい。ここで残る疑問は、Aがどうやって適切なBの実装をインスタンス化するのか、ということだ。理想的には、テストモードと実稼働モードとがあって、2つの異なるBの実装がある、ということをAが知っているべきではない。これはつまり、AがB’またはB＊を直接インスタンス化すべきでないことを意味する。この依存性の問題を解決するには、いくつかの方法がある。1つの選択肢は、AにBファクトリを使わせることだ。この場合、AはBのインスタンスをBファクトリからもらうことができる。Bファクトリを賢くして、インタフェースからBのどの実装を生成するかをBファクトリに決定させればよい。もう1つの方法は、Aは単純にBへの参照を必要としていることを通知する（advertise）だけで、外部環境（たとえば実行時コンテナ）が適切なBの実装を渡すようにするものだ。たとえば、[http://docs.codehaus.org/display/PICO/Inversion+of+Control Pico Container]では、オブジェクトはクラスのコンストラクタを使って、自身が必要とする他のオブジェクトを通知する。コンテナはコンストラクタをチェック（inspect）して、指定された型の適切な実装をインスタンス化し、それをコンポーネントに渡してやる。

== メッセージ注入 (Message Injection) ==

それで、これがメッセージングと何の関係があるのか？　コンポーネントAがデータ処理をしているのを考えてみよう。普通の手続的なアプローチでは、Aがデータソースからデータを呼び出すか、データの生成者がデータを引数にしてAを呼び出すことになる。どちらのシナリオにしても、Aとデータのソースとの間には、直接的なリンクが存在する。今度は、同じようなデータ処理コンポーネントが鎖状になっているとしよう。各コンポーネントがデータを引数に呼び出すタイプだとすると、そこにテストデータを渡すのは簡単である。単にコンポーネントをインスタンス化して、お望みのテストデータを渡して呼び出すだけでいいからだ。しかし、実際にはコンポーネントは次々に別のコンポーネントを呼び出してしまう。単体テストにとって、これは望ましくない。一度に1つのコンポーネントだけをテストしたいからだ。同様に、各コンポーネントがソースからデータを呼び出すタイプだとしても、今度はテストデータをコンポーネントに食わせるために、ソースをテスト用のものに交換しなければならない。

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]メッセージングアーキテクチャは、こうしたコンポーネント間の依存関係を断ち切るのに役立つ。このアーキテクチャ上では、コンポーネントAは特定のコンポーネントにデータを要求したり、特定のコンポーネントにデータを送信することはなくなる。代わりに、コンポーネントAはチャンネルからメッセージを読み取り（consume）、また別のチャンネルにメッセージを書き出す。これが、テスト中にあるコンポーネントの生態系を差し替えるのに、理想的な環境となる。この方法により、コンポーネントの入力チャンネルにテストデータを流し込み、出力チャンネルから正しい結果データが返ってくるのをモニタすることが可能となるのだ。基本的に、コンポーネントAは他のどのコンポーネントとも、直接的な依存関係をもたない。しかし、「制御の反転」コンテナの場合と同様に、どこかで依存関係が解決されなければならない。メッセージングの世界では、依存関係の解決は、次の2つのいずれかの方法で行われる。

 * コンポーネントが自分で1つ以上のチャンネルを選んで、購読・発信を行う。チャンネルは送信者、受信者から分離されているので、この状態でもテスト用データソースからチャンネルにテストデータを流し込むことが可能である。独立したコンポーネント群が1つの大きなシステムとしてまとめ上げられるのは、2つのコンポーネントが同じチャンネルを通して発信または購読することによってである。この構成はは非常に柔軟性が高いが、どのコンポーネントがどのコンポーネントと通信しているのか理解するのが困難になることもある。

 * もう1つは、各コンポーネントに要求されるチャンネルを渡してやる、というものだ。パイプ＆フィルタ型メッセージフローの合成は、合成者（composer）がチャンネルを選んでそれを複数のコンポーネントに渡し、その同一チャンネルを通して発信・購読を行わせることで、実現される。この選択肢では、合成者が異なるチャンネルに対して同じコンポーネントを使い回すことができる。主な欠点は、コンポーネント間の通信を確立するのに、外部の合成者が必要になることだ。

どちらのシナリオにしても、コンポーネント自身が他のコンポーネントへの参照を取得することはなく、1つ以上の特定のメッセージチャンネルを購読することによって自身の要求を「通知する（advertise）」のだ。この性質により、依存性注入に駆り立てるのと同じメリットの多くを享受できる。たとえば、テスト容易性の改善や、あるコンポーネントだけを残るすべてのコンポーネントをインスタンス化することなく実行できること、といったメリットだ。

== データ vs. オブジェクト (Data vs. Objects) ==

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]アーキテクチャは依存性注入と同じ性質をいくつか示しているものの、1つ重要な違いがある。依存性注入の仕組みは、一般的に、コンポーネントにオブジェクトの参照を提供するために使われる。オブジェクトの参照によって、コンポーネントはたとえば永続化、トランザクションのサポートなどといった、便利なサービスを活用できる。メッセージの世界では、メッセージデータはオブジェクトの形で到来するかもしれないが、メッセージからはコンポーネントは何のサービスも利用できない。メッセージは単なるデータの入れ物でしかないからだ。

== ママ見て、ミドルウェアが無いよ！ (Look Ma, No Middleware!) ==

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]アーキテクチャのナイスな性質の1つは、多くの異なる技術の上でこのアーキテクチャを実現できることだ。たとえば、JMSやTIBCO、MQといったサードパーティミドルウェアを使ってこのアーキテクチャを実装することもできる。あるいは、1つのJVMの中に、お手製の!EventChannelクラスを使って実装することもできる（私たちの一番最近のプロジェクトでは、このアプローチを採用した――近いうちに、この経験についてもっと情報を共有するつもり）。どちらの場合でも、このタイプのアーキテクチャでは、個々のコンポーネントを動的に組み立てたり、拡張したりすることが可能で、またコンポーネントのテスト容易性も非常に優れている。