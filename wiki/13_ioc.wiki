#summary メッセージングアーキテクチャにおける依存性注入
#labels 翻訳中

* ！！！ この記事は現在翻訳中です ！！！ *
= メッセージングアーキテクチャにおける依存性注入 =
（原文） http://www.eaipatterns.com/ramblings/13_ioc.html

2004年9月3日

== 依存性注入 (Dependency Injection) ==

たくさんの開発者が最近、制御の反転（IoC）と依存性注入について語っている。私は、他の人が十分に説明しつくしたことを、繰り返すつもりはない。依存性注入の背景にある詳しい議論を知りたい人は、[http://www.martinfowler.com/ Martin Fowler]のこの[http://kakutani.com/trans/fowler/injection.html#FormsOfDependencyInjection 記事]か、Aslak HellesoyとPaul Hammant（英国の同僚!ThoughtWorkerたち）によるこの[http://docs.codehaus.org/display/PICO/Inversion+of+Control 投稿]を参照してほしい。ここでは、皆さんが説明を読まなくて済むように要点だけ説明しよう（私なりの解釈になるが）。オブジェクトAは、オブジェクトBのサービスを利用したいために、Bへの参照が必要だとする。普通のやり方では、Aが「new」コマンドを用いてBのインスタンスを生成する。AはBへの参照を得るので、そのメソッドを呼び出すことができる。さて、ここまではOO初級講座のレッスンみたいで、面白いところは何もない。しかし、状況に応じて、Aが異なるバージョンのBを必要とするとしたら、どうだろう？　たとえば、Bが永続化サービスを提供するとしよう。テスト時には単にファイルにデータを書き込むだけでいいが、実稼働時は商用データベースを使いたいかもしれない。あるいは、Bがメッセージングサービスを提供するとすれば、単体テスト用には同期型の実装を使い、統合テストと実稼働用には非同期の実装を使いたいかもしれない。あるいは、モックのメッセージング層を使って、実際のメッセージングは行わずに、Aが正しいデータをメッセージング層に投げることだけを確認したいかもしれない。

インタフェースや継承、ポリモーフィズムといったオブジェクト指向の構成要素は、共通するインタフェースの背後に異なる実装を隠す、お馴染みのメカニズムを提供してくれる。これらの構成要素を使うと、Aが共通のインタフェースBを通して、そのサービスにアクセスできる。このとき、インタフェースBの実装は、異なる実装B＊とB’のどちらであってもよい。ここで残る疑問は、Aがどうやって適切なBの実装をインスタンス化するのか、ということだ。理想的には、テストモードと実稼働モードとがあって、2つの異なるBの実装がある、ということをAが知っているべきではない。これはつまり、AがB’またはB＊を直接インスタンス化すべきでないことを意味する。この依存性の問題を解決するには、いくつかの方法がある。1つの選択肢は、AにBファクトリを使わせることだ。この場合、AはBのインスタンスをBファクトリからもらうことができる。Bファクトリを賢くして、インタフェースからBのどの実装を生成するかをBファクトリに決定させればよい。もう1つの方法は、Aは単純にBへの参照を必要としていることを通知するだけで、外部環境（たとえば実行時コンテナ）が適切なBの実装を渡すようにするものだ。たとえば、[http://docs.codehaus.org/display/PICO/Inversion+of+Control Pico Container]では、オブジェクトはクラスのコンストラクタを使って、自身が必要とする他のオブジェクトを通知する。コンテナはコンストラクタをチェック（inspect）して、指定された型の適切な実装をインスタンス化し、それをコンポーネントに渡してやる。

== メッセージ注入 (Message Injection) ==

それで、これがメッセージングと何の関係があるのか？　コンポーネントAがデータ処理をしているのを考えてみよう。普通の手続的なアプローチでは、Aがデータソースからデータを呼び出すか、データの生成者がデータを引数にしてAを呼び出すことになる。どちらのシナリオにしても、Aとデータのソースとの間には、直接的なリンクが存在する。今度は、同じようなデータ処理コンポーネントが鎖状になっているとしよう。各コンポーネントがデータを引数に呼び出すタイプだとすると、そこにテストデータを渡すのは簡単である。単にコンポーネントをインスタンス化して、お望みのテストデータを渡して呼び出すだけでいいからだ。しかし、実際にはコンポーネントは次々に別のコンポーネントを呼び出してしまう。単体テストにとって、これは望ましくない。一度に1つのコンポーネントだけをテストしたいからだ。同様に、各コンポーネントがソースからデータを呼び出すタイプだとしても、今度はテストデータをコンポーネントに食わせるために、ソースをテスト用のものに交換しなければならない。

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters] messaging architectures help break these dependencies between components. Component A no longer requests data from a specific component nor does it send data to a specific component. Instead, the component consumes messages of a channel and writes messages to another channel. This makes it ideal to replace a component's ecosystem during testing. This way we can feed test data into the component's input channels and monitor the component's output channels for correct result data. Essentially, component A has no direct dependencies on any other component. However, just as with the Inversion of Control containers somewhere the dependencies must be resolved. In the world of messaging this can happen in one of two ways:

    * The component can subscribe and publish to one or more channels of its choosing. Because channels are decoupled from the sender and receiver we can still use these channels to feed test data from a test data source. The composition of the individual components into a larger system happens by virtue of two components publishing or subscribing to the same channel. This configuration is very flexible but sometimes it can be difficult to understand what component communicates with what other component.

    * Alternatively, we can pass the required channels to each component. Composition of a pipes-and-filters message flow would then happen by virtue of the composer choosing to pass the same channel to multiple components for publication or subscription. This option allows the composer to reuse the same component with different channels. The main drawback is that it does require an external composer to establish connections between components.

In either scenario the component itself does not acquire references to other component but 'advertises' its needs by subscribing to one or more specific message channels. This property gives us many of the same advantages that drives dependency injection, for example improved testability or the ability to execute a component without having to instantiate all other components.

== データ vs. オブジェクト (Data vs. Objects) ==

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]アーキテクチャは依存性注入と同じ性質をいくつか示しているものの、1つ重要な違いがある。依存性注入の仕組みは、一般的に、コンポーネントにオブジェクトの参照を提供するために使われる。オブジェクトの参照によって、コンポーネントはたとえば永続化、トランザクションのサポートなどといった、便利なサービスを活用できる。メッセージの世界では、メッセージデータはオブジェクトの形で到来するかもしれないが、メッセージからはコンポーネントは何のサービスも利用できない。メッセージは単なるデータの入れ物でしかないからだ。

== ママ見て、ミドルウェアが無いよ！ (Look Ma, No Middleware!) ==

[http://www.eaipatterns.com/PipesAndFilters.html Pipes-and-Filters]アーキテクチャのナイスな性質の1つは、多くの異なる技術の中でこのアーキテクチャを実現できることだ。たとえば、JMSやTIBCO、MQといったサードパーティミドルウェアを使ってこのアーキテクチャを実装することもできる。あるいは、1つのJVMの中に、お手製のEventChannelクラスを使って実装することもできる（私たちの一番最近のプロジェクトでは、このアプローチを採用した――近いうちに、この経験についてもっと情報を共有するつもり）。どちらの場合でも、このタイプのアーキテクチャでは、個々のコンポーネントを動的に組み立てたり、拡張したりすることが可能で、またコンポーネントのテスト容易性も非常に優れている。